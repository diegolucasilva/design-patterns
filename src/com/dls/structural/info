In Software Engineering, Structural Design Patterns are Design Patterns that ease the design by
identifying a simple way to realize relationships between entities.

Structural patterns explain how to assemble objects and classes into larger structures
while keeping these structures flexible and efficient.

A structural design pattern serves as a blueprint for how different classes and objects are combined to form larger
structures.
Unlike creational patterns, which are mostly different ways to fulfill the same fundamental purpose,
each structural pattern has a different purpose.


#################################################################################################################

Facade ***
is a structural design pattern that provides a simplified interface to a library, a framework,
or any other complex set of classes.

Adapter **
Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate

Bridge **
Bridge is a structural design pattern that lets you split a large class or a set of closely related classes into two
separate hierarchies—abstraction and implementation—which can be developed independently of each other.

Composite **
The composite pattern is meant to allow treating individual objects and compositions of objects,
or “composites” in the same way.

Decorator **
It is a structural design pattern that lets you attach new behaviors to objects by placing
these objects inside special wrapper objects that contain the behaviors.
Add responsibilities to objects dynamically

Flyweight *
can be recognized by a creation method that returns cached objects instead of creating new.
You can implement shared leaf nodes of the Composite tree as Flyweights to save some RAM.

Proxy *
Proxy is a structural design pattern that lets you provide a substitute or placeholder for another object.
A proxy controls access to the original object, allowing you to perform something either before or after the
request gets through to the original object.